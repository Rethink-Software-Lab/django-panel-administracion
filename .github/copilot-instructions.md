# AI Coding Agent Instructions - Django Panel (Backend)

## Project Overview
**Django 5.0** REST API backend for inventory management. Uses Django Ninja for OpenAPI auto-documentation and role-based access control.

## Architecture

### Stack
- **Framework**: Django 5.0.6 with Django Ninja 1.2.1
- **Language**: Python 3.x
- **Database**: PostgreSQL via psycopg3
- **API Style**: REST with NinjaExtraAPI (auto OpenAPI docs)
- **Auth**: JWT bearer tokens (4-week expiry)
- **Image Storage**: Cloudinary

### Core Apps
```
inventario_v2/           # V2 controllers (MAIN - use this)
├── api.py              # NinjaExtraAPI setup + login endpoint
├── schema.py           # Pydantic schemas for validation
├── models.py           # (empty - uses inventario app models)
├── controllers/        # Feature controllers
│   ├── reportes.py
│   ├── inventario.py
│   ├── cafeteria.py
│   └── utils_reportes/ # Complex report logic
└── migrations/

inventario/             # Legacy V1 (Django models - KEEP IN SYNC)
├── models.py          # All database models defined here
└── migrations/        # Auto-generated by manage.py
```

**Critical**: Models are in `inventario/models.py`, controllers in `inventario_v2/controllers/`.

## Controller Pattern (REQUIRED)

All endpoints use `NinjaExtraAPI` with `@api_controller` decorator:

```python
# inventario_v2/controllers/reportes.py - PATTERN
from ninja_extra import api_controller, route
from ninja import Query

@api_controller("reportes/", tags=["Reportes"], permissions=[])
class ReportesController:
    @route.get("", response=ReportesSchema)
    def getReportes(self, filters: ReportesInput = Query(...)):
        # Auth from AuthBearer middleware
        return {"area": "...", "data": [...]}
```

**Why this pattern**:
- Automatic OpenAPI documentation
- Built-in JWT auth via `AuthBearer` in `api.py`
- Role-based permissions (extend `permissions=[]` as needed)
- Auto response validation against schema

### Register New Controllers
In `inventario_v2/api.py`, add controller to route list:
```python
app.register_controllers(
    YourNewController,
    # ... existing controllers
)
```

## Schema & Validation Pattern

All endpoints use Pydantic schemas (v2) in `inventario_v2/schema.py`:

```python
class ProductoSchema(Schema):
    id: int
    nombre: str
    precio: Decimal
    
    @field_validator("precio")
    @classmethod
    def price_positive(cls, v):
        if v < 0:
            raise ValueError("Must be positive")
        return v
```

**Use for**:
- Request validation (`@route.post(..., auth=...)`)
- Response serialization (`response=ProductoSchema`)
- Query parameters (`filters: FilterSchema = Query(...)`)

## Complex Report Logic

Reports use utility functions in `inventario_v2/controllers/utils_reportes/`:

```python
# reporte_ventas_cafeteria.py - PATTERN
def get_reporte_ventas_cafeteria(desde: date, hasta: date):
    # Step 1: Calculate business logic (labor days, etc)
    dias_laborables = calcular_dias_laborables(desde, hasta)
    
    # Step 2: Query database with complex ORM
    gastos = Gastos.objects.filter(...).annotate(
        custom_field=Case(When(...), default=...)
    )
    
    # Step 3: Process results in memory
    resultado = [format_result(g) for g in gastos]
    
    return resultado
```

**Pattern**: Business logic → DB Query → Format response. Keep functions pure.

## Authentication & Authorization

### Login Flow (in `api.py`)
```python
@app.post("login/", auth=None, response=TokenSchema)
def login(request, data: LoginSchema):
    user = User.objects.get(username=data.username)
    payload = {
        "id": user.pk,
        "rol": user.rol,           # Role for authorization
        "area_venta": user.area_venta,
        "exp": datetime.utcnow() + timedelta(weeks=4),
    }
    token = jwt.encode(payload, settings.SECRET_KEY, algorithm="HS256")
    return {"token": token}
```

### AuthBearer (Automatic)
```python
class AuthBearer(HttpBearer):
    def authenticate(self, request, token):
        # Validates JWT, returns payload
        # Used by @api_controller automatically
```

### Restrict Endpoints by Role
```python
# Future: Add role checking to permissions
@route.get("", response=..., permissions=[IsAdmin()])
def admin_only(self):
    pass
```

## Development Workflow

### Initial Setup
```bash
cd django-panel-administracion
python -m venv venv           # Create virtualenv
source venv/bin/activate      # Activate (Windows: venv\Scripts\activate)
pip install -r requirements.txt
```

### Database Migrations
```bash
python manage.py makemigrations inventario  # After model changes
python manage.py migrate                    # Apply migrations
python manage.py shell                      # Interactive Python shell
```

### Run Server
```bash
python manage.py runserver              # Dev server on 8000
# Then visit http://localhost:8000/api/docs for OpenAPI docs
```

### Tests
```bash
python manage.py test inventario_v2     # Run test suite
python manage.py test inventario_v2.tests.test_reportes --verbosity=2
```

## Model Structure (inventario/models.py)

Key models to understand:

```python
class User(AbstractUser):
    rol: Literal["admin", "vendedor", "almacenero", ...]
    area_venta: ForeignKey(AreaVenta)
    almacen: bool
    
class Productos_Cafeteria(Model):
    nombre: str
    precio_venta: Decimal
    precio_costo: Decimal
    
class Ventas_Cafeteria(Model):
    producto: ForeignKey(Productos_Cafeteria)
    cantidad: int
    fecha: DateTime
    total: Decimal
```

**Before modifying**: Check if field used in `inventario_v2/controllers/` or `db/schema.ts` (Next.js).

## Adding New Features

### Add Endpoint
1. Create model in `inventario/models.py` if needed
2. Run `python manage.py makemigrations && migrate`
3. Create controller in `inventario_v2/controllers/feature.py`
4. Add schema in `inventario_v2/schema.py`
5. Register in `inventario_v2/api.py`
6. Update Next.js `db/schema.ts` via `drizzle-kit generate`
7. Add service in Next.js `app/(with-layout)/services.ts`

### Add Report Logic
1. Create utility function in `inventario_v2/controllers/utils_reportes/[name].py`
2. Use Django ORM with complex queries if needed
3. Add endpoint in `ReportesController`
4. Return Pydantic schema for validation

## File Location Reference

| Purpose | Path |
|---------|------|
| API setup & login | `inventario_v2/api.py` |
| Controllers | `inventario_v2/controllers/[feature].py` |
| Validation schemas | `inventario_v2/schema.py` |
| Models (database) | `inventario/models.py` |
| Model migrations | `inventario/migrations/` |
| Report utilities | `inventario_v2/controllers/utils_reportes/` |
| Settings | `project_inventario/settings.py` |
| URL routing | `project_inventario/urls.py` |

## Code Conventions

### Naming
- **Models**: PascalCase (`User`, `Productos_Cafeteria`)
- **Functions**: snake_case (`get_reporte_ventas_cafeteria`)
- **Variables**: snake_case
- **URL patterns**: kebab-case (`reportes/`, `usuarios/`)

### Query Patterns
```python
# Good: Optimize queries
queryset = Model.objects.filter(...).select_related('fk_field').only('needed_fields')

# Avoid: N+1 queries
for item in Model.objects.all():
    print(item.foreign_key.name)  # Extra query per iteration!
```

### Use Annotations for Complex Logic
```python
# Calculate in DB, not Python
from django.db.models import Sum, Case, When

results = Ventas.objects.annotate(
    total_por_area=Sum(
        'monto',
        filter=Q(area=OuterRef('area'))
    )
).values('area', 'total_por_area')
```

## Important Notes

- **JWT expires**: 4 weeks. Client must refresh token before expiry
- **Cloudinary**: Upload endpoint uses `cloudinary.uploader.upload()`
- **CORS**: Configured in settings for Next.js frontend at localhost:3000
- **PostgreSQL**: Uses Neon serverless - `psycopg` adapter
- **Environment**: `.env` file with `SECRET`, `CLOUD_NAME`, `API_KEY`, etc.

## Common Commands

```bash
# Django shell with models imported
python manage.py shell

# Check for issues
python manage.py check

# Create superuser
python manage.py createsuperuser

# Generate API docs (visible at /api/docs)
# Auto-generated from NinjaExtraAPI
```

## Debugging

- **Test endpoint**: Visit `/api/docs` in browser for OpenAPI UI
- **Check auth**: Look at `AuthBearer.authenticate()` for token validation
- **Query issues**: Use `.explain()` on queryset or raw SQL in shell
- **Logs**: Check terminal output, add `print()` for quick debugging

## Deployment

- **Host**: Vercel or similar Python-capable platform
- **Database**: Neon PostgreSQL (secure connection string in `.env`)
- **Build**: `pip install -r requirements.txt && python manage.py migrate`
- **Secrets**: Add `SECRET`, `CLOUD_NAME`, etc. to platform environment
